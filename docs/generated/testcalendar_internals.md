
<!--This file is autogenerated. Do not edit!-->

### Ham 10k ft structure<a id="quick_internals"></a>

This is the basic structure of HAM

<img src="../images/hamarch02.gif" width="500"/>

### Filters

On each request several filters are executed, dynamically loaded from the libs directory
or for the Javascript filters, from a specific configuration directory.

The filters are listed in the [filters lifecycle](../lifecycle.md) page

They intercept the request according to their selection mechanism and can
change the request and response.

When they are "blocking" the data is directly returned to the client

The filters are the way HAM can do its magic :)

For more infos check the [java filters](../plugins/java/jfilters.md) or the
[Js Filters](../plugins/js.md) plugin.
### Request address rewriters

It is possible to apply a sort of Apache "mod_rewrite" to the system

For example a request to https://www.sample.test can be redirected to 
http://localhost:8080/sample. HAM is taking care of checking that the 
target server is up and running. 

If it's not the case and the server does not run it tries to call https://www.sample.test
### HTTP

When the call to www.google.com reach the internal http server the following happens:

* The request is translated to the internal format
* Starts the [filters lifecycle](../lifecycle.md) when a "blocking" filter is found the result is sent back directly to the client
* The "PRE" filters are called
* The real www.google.com is invoked and the result parsed
* The "POST" filters are called and the data is sent back to the client

### HTTPS

This works with http. But what happens with https and the certificates?

First we need a root CA. This can be downloaded directly from HAM and installed on any
system be it Java, .NET, browser, phone...etc

Given a root CA, HAM is able to generate "on the fly" the certificates configured with
the interface. With this approach is possible to see and parse the content of the https
requests.

This is really a Man In The Middle (MITM) attack!

### Recording

HAM is able to record all requests that are redirected to him, that means
all the calls relative to the DNS names redirected to the local http/s server.

#### DNS capture

With the DNS standard capture all the calls to http servers mapped in HAM dns and 
all the https calls (with the relative certificate added on configuration) are 
recorded

#### The "/int" special path

One special case are proxies with no DNS. They MUST have a path starting with "/int".

If i want to capture the calls from a local (no docker) server to another (no docker)
server. I can't rely on ["proxy rewrite"](../proxy.md) through dns but i have to let the local server
point to "http://localhost/int/[somepath]" and then add a proxy rewrite to the other server
like to "http://localhost:[otherserverlocalport]"

#### The "/db" special path

This is the path used to record database requests

#### No http/s request

All the calls to server other than http/s can't be intercepted completely but you can 
see their DNS names on the "Resolved" DNSes page


### Replaying

#### Basisc

When replaying the request/response resources are catalogued as "static". Or 
resources that never changes during the replay session. And Dynamic. 

The dynamic are executed only -once- during the entire session and a tracker 
is kept to avoid double calls

#### The types

Essentially the replayer has 3 ways to replay

* Replay: You should invoke the "front" service and HAM will respond to the invocations. You are responsible for running the "initiator calls"
* Null Infrastructure: Define a Stimulator, the APIs that will guide the test, and (if present) the Stimulated, the APIs that will be invoked by the system under test. Everything is automatically run
* PACT: Like null, but it invokes the real service and allow the verification of its data and schemas. Everything is automatically run

At the end of a test the result is shown in a specific page/API

#### Extensions

During the replay is possible to associate a PRE and POST Javascript function to modify and verify
the request.

A storage, local to the specific run, is available. And automatic substitutions can be set on path,
headers, query params and bodies
### HAM with proxy<a id="ham_with_proxy"></a>

When a browser/application connect a proxy, the DNS request is handled by the proxy itself.

Following this approach you can intercept any browser ([here the sample](../generated/googlehack.md))
or Android phone ([here the sample](../generated/googlehack_android.md))
